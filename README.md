В работе.

[backend](https://github.com/Tryd0g0lik/cloud)
## Регистрация
![error form registration](./img/formRegistration.png)\
Форма возвращает ошибки если данные введены не верно.

Если пользователь иметтся с таким email, то под формой видим сообщие.

При регистрации, на почту поступает ссылка. Кликая по ссылке, из сообщения, \
подтверждаете email.

После клика , срабатывает 301 код (на сервере) и пользователя пребрассывает на "Главная".\
URL дополнен паррамертрами:
- "`is_session_< user-id >`";
- "`user_session_< user-id >`";
- "`is_active`".

Данные [созраняются](src\components\NavbarTop\index.tsx) в [cookie](src\services\cookieServices.ts).\
**Note**: Изначально строка не имеет временной отметки.

### Login
На cookie ориентируемся для активаци ("`is_active`"). пользователя.\

Каждая загрузка страницы, ориентируясь на "`is_active`", запускает \
параллельно ("`Promise`") две задачи:
 - "`handlerLogin()`";
 - "`changeDOM(true)`" В "`DOM`" добавляет класс "`active`" & "`div#root.active`" или \
 удаляет "`div#root`" если  "`changeDOM(false)`";

**Note:** По умолчанию, входная точка из [changeDOM()](src\services\scripts.ts) имеет значение "`false`".

### handlerLogin()
Может запускаться по событию (уточнить !!!!!) \

#### handlerLogin() дочерная функция.
Делает запрос в cookie и получает значение ключа "`is_session`".\
Если значение есть `true` - пользователь на сайте активирован.

Значит, по шаблону "`/user_session_< user id >/`" получаем имя ключа. Из ключа получаем \
номер `id` (под которым он есть в БД (Базе Данных)).\
"`id`" шифруем и сохраняем с клю.чем "`session`" в "`localstorage`".

- [класс для шифрования](src\services\encrypts.ts).

# Активация
![medssage](/img/errorMessingForm.png)
Два варианта авторизауии. 
При авторизации на сервер, синхронно отправляется 2 запроса. Это вариант кодгда из \
прошлых посищений cookie сохранил данные пользователя. У нас есть индекс. \
На сервере по индексу получаем хеш-ключ. Сравниваем его с тем, что поступил их браузера.
1. Получаем токен.
2. Отправляем данные для авторизации.
**Note**: Если это повторная авторизация , то пользователя (и ключ) берем из cookie

На случай если cookie пустой (браузер почистили), отправляем синхронно 3 запроса.  
1. Получаем токен.
2. Берем email из формы. [Шифруем](src\services\request\loginout.ts) (`AES.encrypt`) и отправляем на сервер.  
3. Отправляем данные для авторизации. Главное, у нас есть индекс. \
Там перебираем базу пользователей в поике данных по email.\
Сравниваем хеш паролей.
**Note**: 
1. База данных имеет два вида кеша. Для паролей. Для ключа польхователя.
Данный ключь регулярно обновляется (с интервалом в 30 минут) пока пользователя сам не выйдет из профиля (`logout`).
1. Для определения пользователя данные берем из формы и на сервере сверяем пароли кешированные.


# Priofile
CRUD - выполнен частично.

После успешной авторизации:
- cookie браузера получает данные;
- пользователь редиректом попадет на страницу профиля
![crud of profile](./img/profileCrud.png)

Два поля:
- `username`;
- `firstname` которые пользователь может редактировать. 

- `email` и `password` просто заложены в логику, но не отработаны.
**Note**: Будьте остарожные с сервером. На сервере  редактирование пароля и email не закладывалось в логику.\
В модель базы данных закладывалось лишь что это уникальные поля и на них основывается "мир". \
В ТЗ нет данных (по пароля и email) для простого пользователя. Только для администора.

 

# COOOKIE если чистый в браузере
Если вдруг, авторизуемся, а cookie чистый.\
Обычно из куки берем индекс жадее идем на серверс.\ 
сверяем. Но главное это "`index`". \
Обчно , синхронно отправляется 2 запроса для авторизации.
1. Получаем токен.
2. Отправляем данные для авторизации.

На случай если cookie пустой, отправляем синхронно 3 запроса.  
1. Получаем токен.
2. Берем email из формы. [Шифруем и отправляем на сервер](src\services\request\loginout.ts).\ Тут работаем `// ENCRYPT` с шифрованием данных для отправки на сервер, с целью востановить индекс. 

3. Отправляем данные для авторизации. Главное, у нас есть индекс.








